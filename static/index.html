<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>è§†é¢‘è‡ªåŠ¨å­—å¹• Â· Whisper æœ¬åœ°ç”Ÿæˆ</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #18181c;
      --border: #2a2a30;
      --text: #e4e4e7;
      --muted: #71717a;
      --accent: #a78bfa;
      --accent-hover: #c4b5fd;
      --success: #34d399;
      --error: #f87171;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "DM Sans", -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
    }
    .page {
      max-width: 560px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      letter-spacing: -0.02em;
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 2rem;
    }
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.25rem;
    }
    .card h2 {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      margin-bottom: 0.75rem;
    }
    label {
      display: block;
      font-size: 0.85rem;
      font-weight: 500;
      margin-bottom: 0.35rem;
    }
    select {
      width: 100%;
      padding: 0.6rem 0.75rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 0.9rem;
      cursor: pointer;
    }
    select:focus {
      outline: none;
      border-color: var(--accent);
    }
    input[type="text"], input[type="password"] {
      width: 100%;
      padding: 0.6rem 0.75rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 0.9rem;
    }
    input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    .row .field { margin-bottom: 0; }
    .row .field:last-of-type { margin-bottom: 0; }
    .field { margin-bottom: 1rem; }
    .api-config-row .field { margin-bottom: 1rem; }
    .api-config-row .field:last-child { margin-bottom: 0; }
    .field:last-child { margin-bottom: 0; }
    .upload-zone {
      border: 2px dashed var(--border);
      border-radius: 10px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }
    .upload-zone:hover, .upload-zone.dragover {
      border-color: var(--accent);
      background: rgba(167, 139, 250, 0.06);
    }
    .upload-zone input { display: none; }
    .upload-zone .icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      opacity: 0.8;
    }
    .upload-zone .hint {
      color: var(--muted);
      font-size: 0.85rem;
    }
    .file-name {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: var(--accent);
      word-break: break-all;
    }
    .btn {
      width: 100%;
      padding: 0.85rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s, transform 0.05s;
    }
    .btn:active { transform: scale(0.98); }
    .btn-primary {
      background: var(--accent);
      color: #0f0f12;
    }
    .btn-primary:hover {
      background: var(--accent-hover);
    }
    .btn-primary:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .mode-hint {
      color: var(--muted);
      font-size: 0.82rem;
      font-weight: 400;
      line-height: 1.4;
      margin-top: 0.45rem;
    }
    .status {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-size: 0.9rem;
      display: none;
    }
    .status.visible { display: block; }
    .status.loading {
      background: rgba(167, 139, 250, 0.12);
      color: var(--accent);
    }
    .status.error {
      background: rgba(248, 113, 113, 0.15);
      color: var(--error);
    }
    .status.success {
      background: rgba(52, 211, 153, 0.12);
      color: var(--success);
    }
    .spinner {
      display: inline-block;
      width: 1em;
      height: 1em;
      border: 2px solid currentColor;
      border-right-color: transparent;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      vertical-align: -0.15em;
      margin-right: 0.4em;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .progress-bar-wrap {
      margin-top: 0.75rem;
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-bar-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .progress-eta {
      margin-top: 0.35rem;
      font-size: 0.8rem;
      color: var(--muted);
    }
    .parallel-detail-panel {
      margin-top: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.02);
      overflow: hidden;
    }
    .parallel-detail-title {
      padding: 0.55rem 0.75rem;
      border-bottom: 1px solid var(--border);
      font-size: 0.82rem;
      color: var(--muted);
      font-weight: 600;
    }
    .parallel-detail-list {
      max-height: 250px;
      overflow: auto;
    }
    .parallel-detail-item {
      padding: 0.58rem 0.75rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
    .parallel-detail-item:last-child {
      border-bottom: none;
    }
    .parallel-detail-top {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      min-width: 0;
    }
    .parallel-detail-index {
      color: var(--muted);
      font-size: 0.78rem;
      flex: 0 0 auto;
    }
    .parallel-detail-file {
      font-size: 0.84rem;
      flex: 1 1 auto;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .parallel-detail-badge {
      flex: 0 0 auto;
      font-size: 0.75rem;
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      border: 1px solid transparent;
    }
    .parallel-detail-badge.queued {
      color: var(--muted);
      border-color: var(--border);
    }
    .parallel-detail-badge.running {
      color: var(--accent);
      border-color: rgba(167, 139, 250, 0.45);
      background: rgba(167, 139, 250, 0.12);
    }
    .parallel-detail-badge.done {
      color: var(--success);
      border-color: rgba(52, 211, 153, 0.45);
      background: rgba(52, 211, 153, 0.1);
    }
    .parallel-detail-badge.fail {
      color: var(--error);
      border-color: rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.12);
    }
    .parallel-detail-badge.canceled {
      color: #fbbf24;
      border-color: rgba(251, 191, 36, 0.45);
      background: rgba(251, 191, 36, 0.12);
    }
    .parallel-detail-sub {
      margin-top: 0.25rem;
      display: flex;
      gap: 0.55rem;
      align-items: baseline;
      color: var(--muted);
      min-width: 0;
    }
    .parallel-detail-progress {
      flex: 0 0 auto;
      font-size: 0.78rem;
    }
    .parallel-detail-message {
      flex: 1 1 auto;
      font-size: 0.78rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .ffmpeg-banner {
      background: rgba(248, 113, 113, 0.12);
      border: 1px solid var(--error);
      border-radius: 10px;
      padding: 0.9rem 1rem;
      margin-bottom: 1.25rem;
      font-size: 0.9rem;
      color: var(--text);
    }
    .ffmpeg-banner.hidden { display: none; }
    .ffmpeg-banner .btn-install {
      margin-top: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--accent);
      color: #0f0f12;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
    }
    .ffmpeg-banner .btn-install:hover { opacity: 0.9; }
    .ffmpeg-banner .btn-install:disabled { opacity: 0.6; cursor: not-allowed; }
    footer {
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      margin-top: 2rem;
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>è§†é¢‘è‡ªåŠ¨å­—å¹•</h1>
    <p class="subtitle">ä¸Šä¼ è§†é¢‘æˆ–éŸ³é¢‘ï¼Œé€‰æ‹© Whisper æ¨¡å‹ä¸è¯­è¨€ï¼Œæœ¬åœ°ç”Ÿæˆ .srt å­—å¹•æ–‡ä»¶</p>

    <div class="card" style="margin-bottom: 1rem;">
      <label for="workMode" style="margin-bottom: 0.35rem;">æ¨¡å¼</label>
      <select id="workMode">
        <option value="transcribe">è½¬å†™ï¼ˆå¯é€‰ç¿»è¯‘ï¼‰</option>
        <option value="translate_only">ä»…ç¿»è¯‘å­—å¹•</option>
      </select>
      <p class="mode-hint" id="workModeHint">è½¬å†™ï¼šä¸Šä¼ è§†é¢‘æˆ–éŸ³é¢‘ï¼Œé€‰æ‹© Whisper æ¨¡å‹ä¸è¯­è¨€ï¼Œæœ¬åœ°ç”Ÿæˆ .srtï¼›å¯é€‰ç¿»è¯‘æˆå¦ä¸€è¯­è¨€</p>
    </div>

    <div class="ffmpeg-banner hidden" id="ffmpegBanner">
      <span id="ffmpegBannerText"></span>
      <div><button type="button" class="btn-install" id="ffmpegInstallBtn">ä¸€é”®ä¸‹è½½å¹¶å®‰è£… ffmpeg</button></div>
    </div>

    <div class="card">
      <h2>é€‰æ‹©æ–‡ä»¶</h2>
      <div class="upload-zone" id="uploadZone">
        <input type="file" id="fileInput" multiple accept=".mp4,.mkv,.avi,.mov,.wmv,.flv,.webm,.m4v,.mp3,.wav,.m4a,.flac,.ogg,.aac,.wma" />
        <div class="icon">ğŸ“</div>
        <div id="uploadZoneLabel">ç‚¹å‡»æˆ–æ‹–æ‹½è§†é¢‘/éŸ³é¢‘åˆ°æ­¤å¤„</div>
        <div class="hint" id="uploadZoneHint">æ”¯æŒ MP4ã€MKVã€AVIã€MOVã€WebMã€MP3ã€WAV ç­‰</div>
        <div class="file-name" id="fileName"></div>
      </div>
    </div>

    <div class="card" id="cardRecognize">
      <h2>è¯†åˆ«è®¾ç½®</h2>
      <div class="row">
        <div class="field">
          <label for="engine">è¯†åˆ«å¼•æ“</label>
          <select id="engine">
            <option value="whisper" selected>Whisperï¼ˆåŸç‰ˆï¼‰</option>
            <option value="faster-whisper">faster-whisperï¼ˆæ›´å¿«ï¼‰</option>
            <option value="purfview-xxl">Purfview XXLï¼ˆexeï¼‰</option>
          </select>
        </div>
        <div class="field">
          <label for="model">Whisper æ¨¡å‹</label>
          <select id="model">
            <option value="tiny">tinyï¼ˆæœ€å¿«ï¼‰</option>
            <option value="tiny.en">tiny.en</option>
            <option value="base" selected>base</option>
            <option value="base.en">base.en</option>
            <option value="small">small</option>
            <option value="small.en">small.en</option>
            <option value="medium">medium</option>
            <option value="medium.en">medium.en</option>
            <option value="large-v1">large-v1</option>
            <option value="large-v2">large-v2</option>
            <option value="large-v3">large-v3</option>
            <option value="large">large</option>
            <option value="large-v3-turbo">large-v3-turbo</option>
            <option value="turbo">turbo</option>
          </select>
        </div>
        <div class="field">
          <label for="language">å­—å¹•è¯­è¨€</label>
          <select id="language">
            <option value="auto" selected>è‡ªåŠ¨æ£€æµ‹</option>
            <option value="zh">ä¸­æ–‡</option>
            <option value="en">English</option>
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="ko">í•œêµ­ì–´</option>
            <option value="fr">FranÃ§ais</option>
            <option value="de">Deutsch</option>
            <option value="es">EspaÃ±ol</option>
            <option value="ru">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
            <option value="pt">PortuguÃªs</option>
            <option value="it">Italiano</option>
            <option value="nl">Nederlands</option>
            <option value="pl">Polski</option>
            <option value="tr">TÃ¼rkÃ§e</option>
            <option value="vi">Tiáº¿ng Viá»‡t</option>
            <option value="th">à¹„à¸—à¸¢</option>
            <option value="id">Indonesia</option>
            <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
            <option value="hi">à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
          </select>
        </div>
      </div>
    </div>

    <div class="card" id="cardTranslate">
      <h2>ç¿»è¯‘ï¼ˆå¯é€‰ï¼‰</h2>
      <p class="hint" style="margin-bottom: 0.75rem;" id="translateHint">å°†è¯†åˆ«å‡ºçš„å­—å¹•ç¿»è¯‘æˆå¦ä¸€ç§è¯­è¨€åå†å¯¼å‡º</p>
      <div class="row">
        <div class="field">
          <label for="translationApi">ç¿»è¯‘ API</label>
          <select id="translationApi">
            <option value="none" selected>ä¸ç¿»è¯‘</option>
            <option value="google">Google ç¿»è¯‘</option>
            <option value="deepl">DeepL</option>
            <option value="openai">OpenAI</option>
            <option value="gemini">Gemini</option>
            <option value="moonshot">Moonshot</option>
          </select>
        </div>
        <div class="field">
          <label for="translateTo">ç¿»è¯‘æˆ</label>
          <select id="translateTo">
            <option value="none" selected>â€”</option>
            <option value="zh">ä¸­æ–‡</option>
            <option value="en">English</option>
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="ko">í•œêµ­ì–´</option>
            <option value="fr">FranÃ§ais</option>
            <option value="de">Deutsch</option>
            <option value="es">EspaÃ±ol</option>
            <option value="ru">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
            <option value="pt">PortuguÃªs</option>
            <option value="it">Italiano</option>
            <option value="nl">Nederlands</option>
            <option value="pl">Polski</option>
            <option value="tr">TÃ¼rkÃ§e</option>
            <option value="vi">Tiáº¿ng Viá»‡t</option>
            <option value="th">à¹„à¸—à¸¢</option>
            <option value="id">Indonesia</option>
            <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
            <option value="hi">à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
          </select>
        </div>
      </div>
      <div id="apiConfigOpenai" class="api-config-block" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
        <div class="field">
          <label for="openaiApiKey">OpenAI API Key</label>
          <input type="password" id="openaiApiKey" placeholder="sk-..." autocomplete="off" />
        </div>
        <div class="field">
          <label for="openaiBaseUrl">OpenAI Base URLï¼ˆå¯é€‰ï¼‰</label>
          <input type="text" id="openaiBaseUrl" placeholder="ä¾‹å¦‚ï¼šhttps://api.openai.com/v1 æˆ–ä½ çš„ä¸­è½¬åœ°å€" autocomplete="off" />
        </div>
        <div class="field">
          <label for="openaiModel">OpenAI ç¿»è¯‘æ¨¡å‹</label>
          <select id="openaiModel">
            <option value="custom">è‡ªå®šä¹‰â€¦</option>
            <option value="gpt-5">gpt-5</option>
            <option value="gpt-4o-mini" selected>gpt-4o-miniï¼ˆæ¨èï¼‰</option>
            <option value="gpt-4o">gpt-4o</option>
            <option value="gpt-4-turbo">gpt-4-turbo</option>
            <option value="gpt-4">gpt-4</option>
            <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
          </select>
        </div>
        <div class="field" id="openaiModelCustomWrap" style="display: none;">
          <label for="openaiModelCustom">è‡ªå®šä¹‰æ¨¡å‹å</label>
          <input type="text" id="openaiModelCustom" placeholder="ä¾‹å¦‚ï¼šgpt-5.2 æˆ– gpt-5mini" autocomplete="off" />
        </div>
        <div class="field">
          <label for="openaiReasoningEffort">OpenAI Reasoning Effortï¼ˆå¯é€‰ï¼‰</label>
          <select id="openaiReasoningEffort">
            <option value="" selected>é»˜è®¤</option>
            <option value="minimal">minimal</option>
            <option value="low">low</option>
            <option value="medium">medium</option>
            <option value="high">high</option>
          </select>
        </div>
      </div>
      <div id="apiConfigGemini" class="api-config-block" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
        <div class="field">
          <label for="geminiApiKey">Gemini API Key</label>
          <input type="password" id="geminiApiKey" placeholder="AIza..." autocomplete="off" />
        </div>
        <div class="field">
          <label for="geminiModel">Gemini ç¿»è¯‘æ¨¡å‹</label>
          <select id="geminiModel">
            <option value="custom">è‡ªå®šä¹‰â€¦</option>
            <option value="gemini-2.5-flash" selected>gemini-2.5-flashï¼ˆæ¨èï¼‰</option>
            <option value="gemini-2.5-pro">gemini-2.5-pro</option>
            <option value="gemini-2.0-flash">gemini-2.0-flash</option>
          </select>
        </div>
        <div class="field" id="geminiModelCustomWrap" style="display: none;">
          <label for="geminiModelCustom">è‡ªå®šä¹‰æ¨¡å‹å</label>
          <input type="text" id="geminiModelCustom" placeholder="ä¾‹å¦‚ï¼šgemini-2.5-flash-lite" autocomplete="off" />
        </div>
        <div class="field">
          <label for="geminiThinkingLevel">Gemini Thinking Levelï¼ˆå¯é€‰ï¼‰</label>
          <input type="text" id="geminiThinkingLevel" placeholder="ä¾‹å¦‚ï¼šMINIMAL / LOW / MEDIUM / HIGHï¼Œç•™ç©ºé»˜è®¤" autocomplete="off" />
        </div>
      </div>
      <div id="apiConfigDeepl" class="api-config-block" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
        <div class="field">
          <label for="deeplApiKey">DeepL API Key</label>
          <input type="password" id="deeplApiKey" placeholder="ç•™ç©ºåˆ™ä½¿ç”¨ç¯å¢ƒå˜é‡" autocomplete="off" />
        </div>
      </div>
      <div id="apiConfigMoonshot" class="api-config-block" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
        <div class="field">
          <label for="moonshotApiKey">Moonshot API Key</label>
          <input type="password" id="moonshotApiKey" placeholder="sk-..." autocomplete="off" />
        </div>
        <div class="field">
          <label for="moonshotBaseUrl">Moonshot Base URLï¼ˆå¯é€‰ï¼‰</label>
          <input type="text" id="moonshotBaseUrl" placeholder="é»˜è®¤ï¼šhttps://api.moonshot.cn/v1" autocomplete="off" />
        </div>
        <div class="field">
          <label for="moonshotModel">Moonshot ç¿»è¯‘æ¨¡å‹</label>
          <select id="moonshotModel">
            <option value="custom">è‡ªå®šä¹‰â€¦</option>
            <option value="kimi-k2-turbo-preview" selected>kimi-k2-turbo-previewï¼ˆæ¨èï¼‰</option>
            <option value="kimi-k2-thinking-turbo">kimi-k2-thinking-turbo</option>
            <option value="kimi-k2-0905-preview">kimi-k2-0905-preview</option>
            <option value="moonshot-v1-8k">moonshot-v1-8k</option>
            <option value="moonshot-v1-32k">moonshot-v1-32k</option>
            <option value="moonshot-v1-128k">moonshot-v1-128k</option>
          </select>
        </div>
        <div class="field" id="moonshotModelCustomWrap" style="display: none;">
          <label for="moonshotModelCustom">è‡ªå®šä¹‰æ¨¡å‹å</label>
          <input type="text" id="moonshotModelCustom" placeholder="ä¾‹å¦‚ï¼škimi-k2" autocomplete="off" />
        </div>
      </div>
      <div id="apiConfigBatch" class="api-config-block" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
        <div class="field">
          <label for="translationBatchSize">æ¯æ‰¹æ¡æ•°ï¼ˆå¯é€‰ï¼‰</label>
          <input type="text" id="translationBatchSize" inputmode="numeric" pattern="[0-9]*" placeholder="ç•™ç©ºåˆ™ä½¿ç”¨é»˜è®¤å€¼" autocomplete="off" />
          <div class="hint" style="margin-top: 0.35rem;">Google / DeepL / OpenAI / Gemini / Moonshot ç¿»è¯‘æ—¶ç”Ÿæ•ˆ</div>
        </div>
        <div class="field">
          <label for="parallelFileCount">å¹¶è¡Œæ–‡ä»¶æ•°ï¼ˆä»… OpenAI / Geminiï¼Œé»˜è®¤ 3ï¼‰</label>
          <input type="text" id="parallelFileCount" inputmode="numeric" pattern="[0-9]*" value="3" autocomplete="off" />
          <div class="hint" style="margin-top: 0.35rem;">ä»…å¤šæ–‡ä»¶ä»»åŠ¡ç”Ÿæ•ˆï¼›å»ºè®® 1~5ï¼Œé»˜è®¤ 3</div>
        </div>
      </div>
      <div id="apiConfigRules" class="api-config-block" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
        <div class="field">
          <label for="translationRules">ç¿»è¯‘é£æ ¼ä¸è§„åˆ™ï¼ˆå¯é€‰ï¼‰</label>
          <textarea id="translationRules" rows="3" placeholder="ä¾‹å¦‚ï¼šä½¿ç”¨æ­£å¼è¯­æ°”ï¼›å“ç‰Œåã€ä¸“æœ‰åè¯ä¿ç•™è‹±æ–‡ï¼›è¯‘æˆç®€ä½“ä¸­æ–‡å£è¯­åŒ–è¡¨è¾¾ã€‚ä»… OpenAI / Gemini / Moonshot ç¿»è¯‘æ—¶ç”Ÿæ•ˆã€‚" style="width:100%;padding:0.6rem 0.75rem;background:var(--bg);border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:0.9rem;resize:vertical;font-family:inherit;"></textarea>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="action-buttons">
        <button type="button" class="btn btn-primary" id="submitBtn" disabled>ç”Ÿæˆå­—å¹•</button>
        <button type="button" class="btn" id="cancelBtn" disabled>ç»ˆæ­¢ä»»åŠ¡</button>
      </div>
      <div class="status" id="status"></div>
      <div class="parallel-detail-panel" id="parallelDetailPanel" style="display: none;">
        <div class="parallel-detail-title">å¹¶è¡Œä»»åŠ¡æ˜ç»†</div>
        <div class="parallel-detail-list" id="parallelDetailList"></div>
      </div>
      <div class="hint" id="downloadList" style="margin-top: 0.6rem;"></div>
      <div class="progress-bar-wrap" id="progressBarWrap" style="display: none;">
        <div class="progress-bar-fill" id="progressBarFill"></div>
      </div>
      <div class="progress-eta" id="progressEta"></div>
    </div>

    <footer>æœ¬åœ°è¿è¡Œ Â· æ•°æ®ä¸ä¸Šä¼  Â· åŸºäº OpenAI Whisper Â· <span id="appVersion"></span></footer>
  </div>

  <script>
    const APP_VERSION = "1.11";
    document.getElementById("appVersion").textContent = "v" + APP_VERSION;

    const uploadZone = document.getElementById("uploadZone");
    const fileInput = document.getElementById("fileInput");
    const fileName = document.getElementById("fileName");
    const engine = document.getElementById("engine");
    const model = document.getElementById("model");
    const language = document.getElementById("language");
    const translationApi = document.getElementById("translationApi");
    const translateTo = document.getElementById("translateTo");
    const openaiApiKey = document.getElementById("openaiApiKey");
    const openaiBaseUrl = document.getElementById("openaiBaseUrl");
    const openaiModel = document.getElementById("openaiModel");
    const openaiModelCustom = document.getElementById("openaiModelCustom");
    const openaiModelCustomWrap = document.getElementById("openaiModelCustomWrap");
    const openaiReasoningEffort = document.getElementById("openaiReasoningEffort");
    const geminiApiKey = document.getElementById("geminiApiKey");
    const geminiModel = document.getElementById("geminiModel");
    const geminiModelCustom = document.getElementById("geminiModelCustom");
    const geminiModelCustomWrap = document.getElementById("geminiModelCustomWrap");
    const geminiThinkingLevel = document.getElementById("geminiThinkingLevel");
    const moonshotApiKey = document.getElementById("moonshotApiKey");
    const moonshotBaseUrl = document.getElementById("moonshotBaseUrl");
    const moonshotModel = document.getElementById("moonshotModel");
    const moonshotModelCustom = document.getElementById("moonshotModelCustom");
    const moonshotModelCustomWrap = document.getElementById("moonshotModelCustomWrap");
    const deeplApiKey = document.getElementById("deeplApiKey");
    const apiConfigOpenai = document.getElementById("apiConfigOpenai");
    const apiConfigGemini = document.getElementById("apiConfigGemini");
    const apiConfigDeepl = document.getElementById("apiConfigDeepl");
    const apiConfigMoonshot = document.getElementById("apiConfigMoonshot");
    const apiConfigBatch = document.getElementById("apiConfigBatch");
    const apiConfigRules = document.getElementById("apiConfigRules");
    const translationBatchSize = document.getElementById("translationBatchSize");
    const parallelFileCount = document.getElementById("parallelFileCount");
    const translationRules = document.getElementById("translationRules");
    const submitBtn = document.getElementById("submitBtn");
    const cancelBtn = document.getElementById("cancelBtn");
    const statusEl = document.getElementById("status");
    const parallelDetailPanel = document.getElementById("parallelDetailPanel");
    const parallelDetailList = document.getElementById("parallelDetailList");
    const downloadList = document.getElementById("downloadList");
    const progressBarWrap = document.getElementById("progressBarWrap");
    const progressBarFill = document.getElementById("progressBarFill");
    const progressEta = document.getElementById("progressEta");
    const ffmpegBanner = document.getElementById("ffmpegBanner");
    const ffmpegBannerText = document.getElementById("ffmpegBannerText");
    const ffmpegInstallBtn = document.getElementById("ffmpegInstallBtn");
    const workMode = document.getElementById("workMode");
    const uploadZoneLabel = document.getElementById("uploadZoneLabel");
    const uploadZoneHint = document.getElementById("uploadZoneHint");
    const cardRecognize = document.getElementById("cardRecognize");
    const cardTranslate = document.getElementById("cardTranslate");
    const translateHint = document.getElementById("translateHint");
    const workModeHint = document.getElementById("workModeHint");

    const STORAGE_KEY = "auto_subbed_api_config";
    const SETTINGS_KEY = "auto_subbed_settings";
    const activeJobIds = new Set();
    const parallelTaskStates = new Map();
    let selectedFiles = [];
    let stopQueue = false;
    let parallelRunEnabled = false;
    let parallelTotalFiles = 0;
    let parallelFileNames = [];
    let autoDownloadChain = Promise.resolve();

    function updateModeUI() {
      const onlyTranslate = workMode.value === "translate_only";
      cardRecognize.style.display = onlyTranslate ? "none" : "block";
      if (onlyTranslate) {
        ffmpegBanner.classList.add("hidden");
      } else {
        checkFfmpegAndShowBanner();
      }
      if (onlyTranslate) {
        workModeHint.textContent = "ä»…ç¿»è¯‘ï¼šä¸Šä¼ å·²æœ‰ .srtï¼Œç›´æ¥ç¿»è¯‘æˆç›®æ ‡è¯­è¨€ï¼Œä¸è¿›è¡Œè¯­éŸ³è¯†åˆ«";
        fileInput.accept = ".srt";
        uploadZoneLabel.textContent = "ç‚¹å‡»æˆ–æ‹–æ‹½ .srt å­—å¹•æ–‡ä»¶åˆ°æ­¤å¤„";
        uploadZoneHint.textContent = "ä»…æ”¯æŒ .srt æ ¼å¼";
        cardTranslate.querySelector("h2").textContent = "ç¿»è¯‘";
        translateHint.textContent = "é€‰æ‹©ç¿»è¯‘ API ä¸ç›®æ ‡è¯­è¨€ï¼Œå¯¼å‡ºç¿»è¯‘åçš„ .srt";
        submitBtn.textContent = "ç¿»è¯‘å­—å¹•";
      } else {
        workModeHint.textContent = "è½¬å†™ï¼šä¸Šä¼ è§†é¢‘æˆ–éŸ³é¢‘ï¼Œé€‰æ‹© Whisper æ¨¡å‹ä¸è¯­è¨€ï¼Œæœ¬åœ°ç”Ÿæˆ .srtï¼›å¯é€‰ç¿»è¯‘æˆå¦ä¸€è¯­è¨€";
        fileInput.accept = ".mp4,.mkv,.avi,.mov,.wmv,.flv,.webm,.m4v,.mp3,.wav,.m4a,.flac,.ogg,.aac,.wma";
        uploadZoneLabel.textContent = "ç‚¹å‡»æˆ–æ‹–æ‹½è§†é¢‘/éŸ³é¢‘åˆ°æ­¤å¤„";
        uploadZoneHint.textContent = "æ”¯æŒ MP4ã€MKVã€AVIã€MOVã€WebMã€MP3ã€WAV ç­‰";
        cardTranslate.querySelector("h2").textContent = "ç¿»è¯‘ï¼ˆå¯é€‰ï¼‰";
        translateHint.textContent = "å°†è¯†åˆ«å‡ºçš„å­—å¹•ç¿»è¯‘æˆå¦ä¸€ç§è¯­è¨€åå†å¯¼å‡º";
        submitBtn.textContent = "ç”Ÿæˆå­—å¹•";
      }
      fileInput.files = null;
      fileName.textContent = "";
      selectedFiles = [];
      submitBtn.disabled = true;
      cancelBtn.disabled = true;
      activeJobIds.clear();
      parallelTaskStates.clear();
      parallelRunEnabled = false;
      parallelTotalFiles = 0;
      parallelFileNames = [];
      parallelDetailList.innerHTML = "";
      parallelDetailPanel.style.display = "none";
    }
    async function checkFfmpegAndShowBanner() {
      try {
        const res = await fetch("/api/ffmpeg/status");
        const data = await res.json();
        if (data.available) {
          ffmpegBanner.classList.add("hidden");
          return;
        }
        ffmpegBannerText.textContent = data.error || "æœªæ£€æµ‹åˆ° ffmpegã€‚";
        ffmpegBanner.classList.remove("hidden");
      } catch (_) {
        ffmpegBanner.classList.add("hidden");
      }
    }
    checkFfmpegAndShowBanner();

    ffmpegInstallBtn.addEventListener("click", async () => {
      ffmpegInstallBtn.disabled = true;
      ffmpegBannerText.textContent = "æ­£åœ¨ä¸‹è½½å¹¶å®‰è£… ffmpegï¼Œè¯·ç¨å€™ï¼ˆçº¦ 1ï½2 åˆ†é’Ÿï¼‰â€¦";
      try {
        const res = await fetch("/api/ffmpeg/install", { method: "POST" });
        const data = await res.json();
        if (data.success) {
          ffmpegBanner.classList.add("hidden");
        } else {
          ffmpegBannerText.textContent = data.message || "å®‰è£…å¤±è´¥";
          ffmpegInstallBtn.disabled = false;
        }
      } catch (e) {
        ffmpegBannerText.textContent = "å®‰è£…è¯·æ±‚å¤±è´¥ï¼š" + (e.message || String(e));
        ffmpegInstallBtn.disabled = false;
      }
    });

    cancelBtn.addEventListener("click", async () => {
      stopQueue = true;
      if (!activeJobIds.size) {
        showStatus("å·²åœæ­¢é˜Ÿåˆ—", "success");
        cancelBtn.disabled = true;
        return;
      }
      cancelBtn.disabled = true;
      try {
        const ids = Array.from(activeJobIds);
        await Promise.all(ids.map((id) => fetch(`/api/jobs/${id}/cancel`, { method: "POST" }).catch(() => null)));
        if (parallelRunEnabled && parallelTotalFiles > 0) {
          for (let i = 1; i <= parallelTotalFiles; i++) {
            const state = parallelTaskStates.get(i) || { fileName: parallelFileNames[i - 1] || `æ–‡ä»¶ ${i}` };
            if (state.status !== "done" && state.status !== "fail" && state.status !== "canceled") {
              parallelTaskStates.set(i, { ...state, status: "canceled", message: "å·²åœæ­¢", progress: Number.isFinite(state.progress) ? state.progress : 0 });
            }
          }
          renderParallelStatus();
          renderParallelDetails();
        }
        showStatus(`å·²è¯·æ±‚ç»ˆæ­¢ ${ids.length} ä¸ªè¿è¡Œä¸­ä»»åŠ¡ï¼Œå¹¶åœæ­¢åç»­é˜Ÿåˆ—`, "success");
      } catch (_) {
        showStatus("ç»ˆæ­¢ä»»åŠ¡è¯·æ±‚å¤±è´¥", "error");
      }
    });

    function loadApiConfig() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (data.openai_api_key) openaiApiKey.value = data.openai_api_key;
        if (data.openai_base_url) openaiBaseUrl.value = data.openai_base_url;
        if (data.openai_model) openaiModel.value = data.openai_model;
        if (data.openai_model_custom) openaiModelCustom.value = data.openai_model_custom;
        if (data.openai_reasoning_effort != null) openaiReasoningEffort.value = data.openai_reasoning_effort;
        if (data.gemini_api_key) geminiApiKey.value = data.gemini_api_key;
        if (data.gemini_model) geminiModel.value = data.gemini_model;
        if (data.gemini_model_custom) geminiModelCustom.value = data.gemini_model_custom;
        if (data.gemini_thinking_level) geminiThinkingLevel.value = data.gemini_thinking_level;
        if (data.moonshot_api_key) moonshotApiKey.value = data.moonshot_api_key;
        if (data.moonshot_base_url) moonshotBaseUrl.value = data.moonshot_base_url;
        if (data.moonshot_model) moonshotModel.value = data.moonshot_model;
        if (data.moonshot_model_custom) moonshotModelCustom.value = data.moonshot_model_custom;
        if (data.deepl_api_key) deeplApiKey.value = data.deepl_api_key;
        if (data.translation_batch_size) translationBatchSize.value = data.translation_batch_size;
        if (data.translation_rules != null) translationRules.value = data.translation_rules;
      } catch (_) {}
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (data.work_mode) workMode.value = data.work_mode;
        if (data.engine) engine.value = data.engine;
        if (data.model) model.value = data.model;
        if (data.language) language.value = data.language;
        if (data.translation_api) translationApi.value = data.translation_api;
        if (data.translate_to) translateTo.value = data.translate_to;
        if (data.parallel_file_count) parallelFileCount.value = data.parallel_file_count;
      } catch (_) {}
    }

    function saveSettings() {
      try {
        const data = {
          work_mode: workMode.value,
          engine: engine.value,
          model: model.value,
          language: language.value,
          translation_api: translationApi.value,
          translate_to: translateTo.value,
          parallel_file_count: parallelFileCount.value.trim(),
        };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(data));
      } catch (_) {}
    }

    function saveApiConfig() {
      try {
        const data = {
          openai_api_key: openaiApiKey.value.trim(),
          openai_base_url: openaiBaseUrl.value.trim(),
          openai_model: openaiModel.value,
          openai_model_custom: openaiModelCustom.value.trim(),
          openai_reasoning_effort: openaiReasoningEffort.value,
          gemini_api_key: geminiApiKey.value.trim(),
          gemini_model: geminiModel.value,
          gemini_model_custom: geminiModelCustom.value.trim(),
          gemini_thinking_level: geminiThinkingLevel.value.trim(),
          moonshot_api_key: moonshotApiKey.value.trim(),
          moonshot_base_url: moonshotBaseUrl.value.trim(),
          moonshot_model: moonshotModel.value,
          moonshot_model_custom: moonshotModelCustom.value.trim(),
          deepl_api_key: deeplApiKey.value.trim(),
          translation_batch_size: translationBatchSize.value.trim(),
          translation_rules: translationRules.value,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (_) {}
    }

    function showApiConfigFor(api) {
      apiConfigOpenai.style.display = api === "openai" ? "block" : "none";
      apiConfigGemini.style.display = api === "gemini" ? "block" : "none";
      apiConfigDeepl.style.display = api === "deepl" ? "block" : "none";
      apiConfigMoonshot.style.display = api === "moonshot" ? "block" : "none";
      apiConfigBatch.style.display = api !== "none" ? "block" : "none";
      apiConfigRules.style.display = (api === "openai" || api === "gemini" || api === "moonshot") ? "block" : "none";
    }

    loadApiConfig();
    loadSettings();
    updateModeUI();
    showApiConfigFor(translationApi.value);
    translationApi.addEventListener("change", () => {
      showApiConfigFor(translationApi.value);
      saveSettings();
    });
    openaiModelCustomWrap.style.display = openaiModel.value === "custom" ? "block" : "none";
    openaiModel.addEventListener("change", () => {
      openaiModelCustomWrap.style.display = openaiModel.value === "custom" ? "block" : "none";
      saveApiConfig();
    });
    moonshotModelCustomWrap.style.display = moonshotModel.value === "custom" ? "block" : "none";
    moonshotModel.addEventListener("change", () => {
      moonshotModelCustomWrap.style.display = moonshotModel.value === "custom" ? "block" : "none";
      saveApiConfig();
    });
    geminiModelCustomWrap.style.display = geminiModel.value === "custom" ? "block" : "none";
    geminiModel.addEventListener("change", () => {
      geminiModelCustomWrap.style.display = geminiModel.value === "custom" ? "block" : "none";
      saveApiConfig();
    });
    workMode.addEventListener("change", () => {
      updateModeUI();
      saveSettings();
    });
    engine.addEventListener("change", saveSettings);
    model.addEventListener("change", saveSettings);
    language.addEventListener("change", saveSettings);
    translateTo.addEventListener("change", saveSettings);
    parallelFileCount.addEventListener("change", saveSettings);
    parallelFileCount.addEventListener("blur", saveSettings);

    openaiApiKey.addEventListener("change", saveApiConfig);
    openaiApiKey.addEventListener("blur", saveApiConfig);
    openaiBaseUrl.addEventListener("change", saveApiConfig);
    openaiBaseUrl.addEventListener("blur", saveApiConfig);
    openaiReasoningEffort.addEventListener("change", saveApiConfig);
    openaiModelCustom.addEventListener("change", saveApiConfig);
    openaiModelCustom.addEventListener("blur", saveApiConfig);
    geminiApiKey.addEventListener("change", saveApiConfig);
    geminiApiKey.addEventListener("blur", saveApiConfig);
    geminiModelCustom.addEventListener("change", saveApiConfig);
    geminiModelCustom.addEventListener("blur", saveApiConfig);
    geminiThinkingLevel.addEventListener("change", saveApiConfig);
    geminiThinkingLevel.addEventListener("blur", saveApiConfig);
    moonshotApiKey.addEventListener("change", saveApiConfig);
    moonshotApiKey.addEventListener("blur", saveApiConfig);
    moonshotBaseUrl.addEventListener("change", saveApiConfig);
    moonshotBaseUrl.addEventListener("blur", saveApiConfig);
    moonshotModelCustom.addEventListener("change", saveApiConfig);
    moonshotModelCustom.addEventListener("blur", saveApiConfig);
    deeplApiKey.addEventListener("change", saveApiConfig);
    deeplApiKey.addEventListener("blur", saveApiConfig);
    translationBatchSize.addEventListener("change", saveApiConfig);
    translationBatchSize.addEventListener("blur", saveApiConfig);
    translationRules.addEventListener("change", saveApiConfig);
    translationRules.addEventListener("blur", saveApiConfig);

    function showStatus(msg, type) {
      statusEl.innerHTML = msg;
      statusEl.className = "status visible " + type;
    }
    function hideStatus() {
      statusEl.className = "status";
      progressBarWrap.style.display = "none";
      progressEta.textContent = "";
      downloadList.innerHTML = "";
      parallelDetailList.innerHTML = "";
      parallelDetailPanel.style.display = "none";
    }

    function escapeHtml(value) {
      return String(value == null ? "" : value).replace(/[&<>"']/g, (ch) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "\"": "&quot;",
        "'": "&#39;",
      })[ch] || ch);
    }

    function getParallelStatusMeta(status) {
      if (status === "running") return { label: "æ‰§è¡Œä¸­", cls: "running" };
      if (status === "done") return { label: "å®Œæˆ", cls: "done" };
      if (status === "fail") return { label: "å¤±è´¥", cls: "fail" };
      if (status === "canceled") return { label: "å·²åœæ­¢", cls: "canceled" };
      return { label: "æ’é˜Ÿä¸­", cls: "queued" };
    }

    function renderParallelDetails() {
      if (!parallelRunEnabled || parallelTotalFiles <= 1) {
        parallelDetailList.innerHTML = "";
        parallelDetailPanel.style.display = "none";
        return;
      }
      const rows = [];
      for (let i = 1; i <= parallelTotalFiles; i++) {
        const state = parallelTaskStates.get(i) || {};
        const status = state.status || "queued";
        const fileLabel = state.fileName || parallelFileNames[i - 1] || `æ–‡ä»¶ ${i}`;
        const progress = Number.isFinite(state.progress) ? Math.max(0, Math.min(100, Math.round(state.progress))) : 0;
        const message = state.message || (status === "queued" ? "ç­‰å¾…è°ƒåº¦â€¦" : "");
        const meta = getParallelStatusMeta(status);
        rows.push(
          `<div class="parallel-detail-item">` +
          `<div class="parallel-detail-top">` +
          `<span class="parallel-detail-index">#${i}</span>` +
          `<span class="parallel-detail-file">${escapeHtml(fileLabel)}</span>` +
          `<span class="parallel-detail-badge ${meta.cls}">${meta.label}</span>` +
          `</div>` +
          `<div class="parallel-detail-sub">` +
          `<span class="parallel-detail-progress">${progress}%</span>` +
          `<span class="parallel-detail-message">${escapeHtml(message)}</span>` +
          `</div>` +
          `</div>`
        );
      }
      parallelDetailList.innerHTML = rows.join("");
      parallelDetailPanel.style.display = "block";
    }

    function queueAutoDownload(url, filename) {
      autoDownloadChain = autoDownloadChain.then(async () => {
        try {
          await triggerDownload(url, filename);
        } catch (_) {
          // è‡ªåŠ¨ä¸‹è½½å¯èƒ½è¢«æµè§ˆå™¨æ‹¦æˆªï¼Œä¿ç•™å¯ç‚¹å‡»é“¾æ¥
        }
        await new Promise((r) => setTimeout(r, 150));
      });
      return autoDownloadChain;
    }

    function renderParallelStatus() {
      if (!parallelRunEnabled || parallelTotalFiles <= 0) return;
      let done = 0;
      let fail = 0;
      let canceled = 0;
      let running = 0;
      let progressSum = 0;
      for (let i = 1; i <= parallelTotalFiles; i++) {
        const s = parallelTaskStates.get(i);
        if (!s) continue;
        const p = Number.isFinite(s.progress) ? Math.max(0, Math.min(100, s.progress)) : 0;
        progressSum += p;
        if (s.status === "done") done += 1;
        else if (s.status === "fail") fail += 1;
        else if (s.status === "canceled") canceled += 1;
        else if (s.status === "running") running += 1;
      }
      const queued = Math.max(0, parallelTotalFiles - done - fail - canceled - running);
      const overall = Math.round(progressSum / parallelTotalFiles);
      showProgress(overall, null);
      const msg = `å¹¶è¡Œæ‰§è¡Œä¸­ï¼šè¿è¡Œ ${running}ï¼Œæ’é˜Ÿ ${queued}ï¼Œå®Œæˆ ${done}ï¼Œå¤±è´¥ ${fail}ï¼Œåœæ­¢ ${canceled}`;
      const type = running > 0 ? "loading" : (fail > 0 ? "error" : "success");
      showStatus(running > 0 ? `<span class="spinner"></span>${msg}` : msg, type);
    }

    function setParallelTaskState(index, patch) {
      if (!parallelRunEnabled) return;
      const prev = parallelTaskStates.get(index) || {};
      parallelTaskStates.set(index, { ...prev, ...patch });
      renderParallelStatus();
      renderParallelDetails();
    }

    async function triggerDownload(url, preferredName) {
      const dlRes = await fetch(url);
      if (!dlRes.ok) throw new Error(dlRes.statusText);
      const blob = await dlRes.blob();
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = preferredName || "subtitle.srt";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function addDownloadLink(label, url, filename) {
      const a = document.createElement("a");
      a.href = "#";
      a.textContent = label;
      a.style.display = "block";
      a.style.marginTop = "0.25rem";
      a.style.color = "var(--accent)";
      a.addEventListener("click", async (e) => {
        e.preventDefault();
        try {
          await triggerDownload(url, filename);
        } catch (err) {
          showStatus("ä¸‹è½½å¤±è´¥ï¼š" + (err.message || String(err)), "error");
        }
      });
      downloadList.appendChild(a);
    }
    function showProgress(percent, etaSeconds) {
      if (percent == null) {
        progressBarWrap.style.display = "none";
        progressEta.textContent = "";
        return;
      }
      progressBarWrap.style.display = "block";
      progressBarFill.style.width = Math.min(100, Math.max(0, percent)) + "%";
      if (etaSeconds != null && etaSeconds > 0) {
        const m = Math.floor(etaSeconds / 60);
        const s = etaSeconds % 60;
        progressEta.textContent = m ? `çº¦å‰©ä½™ ${m} åˆ† ${s} ç§’` : `çº¦å‰©ä½™ ${etaSeconds} ç§’`;
      } else {
        progressEta.textContent = "";
      }
    }

    uploadZone.addEventListener("click", () => fileInput.click());
    uploadZone.addEventListener("dragover", (e) => { e.preventDefault(); uploadZone.classList.add("dragover"); });
    uploadZone.addEventListener("dragleave", () => uploadZone.classList.remove("dragover"));
    uploadZone.addEventListener("drop", (e) => {
      e.preventDefault();
      uploadZone.classList.remove("dragover");
      const files = Array.from(e.dataTransfer.files || []);
      if (files.length) setFiles(files);
    });
    fileInput.addEventListener("change", () => {
      const files = Array.from(fileInput.files || []);
      if (files.length) setFiles(files);
    });

    function setFiles(files) {
      selectedFiles = files.slice();
      fileInput.files = null;
      const dt = new DataTransfer();
      selectedFiles.forEach((f) => dt.items.add(f));
      fileInput.files = dt.files;
      if (selectedFiles.length === 1) {
        fileName.textContent = selectedFiles[0].name;
      } else {
        fileName.textContent = `å·²é€‰æ‹© ${selectedFiles.length} ä¸ªæ–‡ä»¶ï¼ˆ${selectedFiles[0].name} ç­‰ï¼‰`;
      }
      submitBtn.disabled = false;
      hideStatus();
    }

    function getParallelFileCount() {
      const n = parseInt(parallelFileCount.value, 10);
      if (!Number.isFinite(n) || n <= 0) return 3;
      return Math.min(8, n);
    }

    async function runSingleFileTask(file, onlyTranslate, queueIndex, queueTotal, batchMode) {
      const form = new FormData();
      form.append("file", file);
      form.append("translation_api", translationApi.value);
      form.append("translate_to", translateTo.value);
      if (openaiApiKey.value.trim()) form.append("openai_api_key", openaiApiKey.value.trim());
      if (openaiBaseUrl.value.trim()) form.append("openai_base_url", openaiBaseUrl.value.trim());
      if (openaiReasoningEffort.value) form.append("openai_reasoning_effort", openaiReasoningEffort.value);
      if (geminiApiKey.value.trim()) form.append("gemini_api_key", geminiApiKey.value.trim());
      if (geminiThinkingLevel.value.trim()) form.append("gemini_thinking_level", geminiThinkingLevel.value.trim());
      if (moonshotApiKey.value.trim()) form.append("moonshot_api_key", moonshotApiKey.value.trim());
      if (moonshotBaseUrl.value.trim()) form.append("moonshot_base_url", moonshotBaseUrl.value.trim());
      if (deeplApiKey.value.trim()) form.append("deepl_api_key", deeplApiKey.value.trim());
      const selectedOpenaiModel = openaiModel.value === "custom"
        ? (openaiModelCustom.value.trim() || "gpt-4o-mini")
        : openaiModel.value;
      const selectedGeminiModel = geminiModel.value === "custom"
        ? (geminiModelCustom.value.trim() || "gemini-2.5-flash")
        : geminiModel.value;
      const selectedMoonshotModel = moonshotModel.value === "custom"
        ? (moonshotModelCustom.value.trim() || "kimi-k2-turbo-preview")
        : moonshotModel.value;
      form.append("openai_model", selectedOpenaiModel);
      form.append("gemini_model", selectedGeminiModel);
      form.append("moonshot_model", selectedMoonshotModel);
      const batchSize = parseInt(translationBatchSize.value, 10);
      if (Number.isFinite(batchSize) && batchSize > 0) {
        form.append("translation_batch_size", String(batchSize));
      }
      if (translationRules.value.trim()) form.append("translation_rules", translationRules.value.trim());

      const apiUrl = onlyTranslate ? "/api/translate" : "/api/transcribe";
      if (!onlyTranslate) {
        form.append("engine", engine.value);
        form.append("model_name", model.value);
        form.append("language", language.value);
      }

      const startRes = await fetch(apiUrl, { method: "POST", body: form });
      if (!startRes.ok) {
        const err = await startRes.json().catch(() => ({ detail: startRes.statusText }));
        throw new Error(err.detail || startRes.statusText);
      }
      const { job_id } = await startRes.json();
      if (!job_id) throw new Error("ä»»åŠ¡å¯åŠ¨å¤±è´¥ï¼Œæœªè¿”å› job_id");
      activeJobIds.add(job_id);
      const useParallelUI = parallelRunEnabled && batchMode;
      if (useParallelUI) {
        setParallelTaskState(queueIndex, {
          status: "running",
          progress: 0,
          fileName: file.name,
          message: "ä»»åŠ¡å·²å¯åŠ¨",
        });
      }

      let originalDownloaded = false;
      let lastJobMsg = "";
      let lastJobMsgAt = Date.now();
      const buildDownloadUrl = (fileParam) =>
        fileParam ? `/api/jobs/${job_id}/download?file=${fileParam}` : `/api/jobs/${job_id}/download`;
      const downloadOne = async (fileParam, defaultName) => {
        await triggerDownload(buildDownloadUrl(fileParam), defaultName);
      };

      try {
        while (true) {
          if (stopQueue) {
            throw new Error("é˜Ÿåˆ—å·²åœæ­¢");
          }
          const jobRes = await fetch(`/api/jobs/${job_id}`);
          if (!jobRes.ok) {
            const err = await jobRes.json().catch(() => ({ detail: jobRes.statusText }));
            throw new Error(err.detail || jobRes.statusText);
          }
          const job = await jobRes.json();
          if (!originalDownloaded && job.filename_original) {
            if (batchMode) {
              addDownloadLink(
                `[${queueIndex}] åŸå­—å¹•ï¼š${job.filename_original}`,
                `/api/jobs/${job_id}/download?file=original`,
                job.filename_original
              );
              if (useParallelUI) {
                queueAutoDownload(buildDownloadUrl("original"), job.filename_original);
              } else {
                try {
                  await downloadOne("original", job.filename_original);
                } catch (_) {
                  // è‡ªåŠ¨ä¸‹è½½å¯èƒ½è¢«æµè§ˆå™¨æ‹¦æˆªï¼Œä¿ç•™å¯ç‚¹å‡»é“¾æ¥
                }
              }
            } else {
              await downloadOne("original", job.filename_original);
            }
            originalDownloaded = true;
          }
          if (job.status === "error") {
            if (originalDownloaded) {
              const partialFailMsg = `æ–‡ä»¶ ${queueIndex}/${queueTotal}ï¼šç¿»è¯‘å¤±è´¥ï¼Œä½†åŸå­—å¹•å·²ä¸‹è½½`;
              if (useParallelUI) {
                setParallelTaskState(queueIndex, {
                  status: "fail",
                  progress: 100,
                  message: partialFailMsg,
                });
              } else {
                showStatus(partialFailMsg, "error");
              }
              return { ok: false };
            }
            throw new Error(job.error || "ä»»åŠ¡å¤±è´¥");
          }
          if (job.status === "canceled") {
            throw new Error("ä»»åŠ¡å·²å–æ¶ˆ");
          }
          if (job.status === "done") {
            if (batchMode) {
              const finalName = job.filename || file.name.replace(/\.[^.]+$/, "") + ".srt";
              addDownloadLink(
                `[${queueIndex}] ç¿»è¯‘/å­—å¹•ï¼š${finalName}`,
                `/api/jobs/${job_id}/download`,
                finalName
              );
              if (useParallelUI) {
                queueAutoDownload(buildDownloadUrl("translated"), finalName);
              } else {
                try {
                  await downloadOne("translated", finalName);
                } catch (_) {
                  // è‡ªåŠ¨ä¸‹è½½å¯èƒ½è¢«æµè§ˆå™¨æ‹¦æˆªï¼Œä¿ç•™å¯ç‚¹å‡»é“¾æ¥
                }
              }
            } else if (job.filename_original) {
              if (!originalDownloaded) {
                await downloadOne("original", job.filename_original);
              }
              await downloadOne("translated", job.filename || file.name.replace(/\.[^.]+$/, "") + ".srt");
            } else {
              await downloadOne(null, job.filename || file.name.replace(/\.[^.]+$/, "") + ".srt");
            }
            if (useParallelUI) {
              setParallelTaskState(queueIndex, {
                status: "done",
                progress: 100,
                fileName: file.name,
                message: "å®Œæˆ",
              });
            } else {
              showProgress(100, null);
              showStatus(`æ–‡ä»¶ ${queueIndex}/${queueTotal} å®Œæˆï¼š${file.name}`, "success");
            }
            return { ok: true };
          }
          const progressVal = (job.progress === null || job.progress === undefined) ? null : job.progress;
          const msg = job.message || "å¤„ç†ä¸­â€¦";
          if (msg !== lastJobMsg) {
            lastJobMsg = msg;
            lastJobMsgAt = Date.now();
          }
          let msgDisplay = msg;
          const waitingSec = Math.floor((Date.now() - lastJobMsgAt) / 1000);
          if ((job.stage === "translating" || job.stage === "transcribing") && (progressVal === 0 || progressVal === null) && waitingSec >= 10) {
            msgDisplay = `${msg}ï¼ˆç­‰å¾…æ¨¡å‹å“åº”ä¸­ ${waitingSec}sï¼‰`;
          }
          if (useParallelUI) {
            setParallelTaskState(queueIndex, {
              status: "running",
              progress: progressVal == null ? 0 : progressVal,
              fileName: file.name,
              message: msgDisplay,
            });
          } else {
            showStatus(`<span class="spinner"></span>[${queueIndex}/${queueTotal}] ${file.name}ï¼š${msgDisplay}`, "loading");
            showProgress(progressVal, job.eta_seconds ?? null);
          }
          await new Promise((r) => setTimeout(r, 1000));
        }
      } finally {
        activeJobIds.delete(job_id);
      }
    }

    submitBtn.addEventListener("click", async () => {
      const files = selectedFiles.length ? selectedFiles : Array.from(fileInput.files || []);
      const onlyTranslate = workMode.value === "translate_only";
      const batchMode = files.length > 1;
      if (!files.length) {
        showStatus(onlyTranslate ? "è¯·å…ˆé€‰æ‹© .srt å­—å¹•æ–‡ä»¶" : "è¯·å…ˆé€‰æ‹©è§†é¢‘æˆ–éŸ³é¢‘æ–‡ä»¶", "error");
        return;
      }
      if (onlyTranslate) {
        if (files.some((f) => !f.name.toLowerCase().endsWith(".srt"))) {
          showStatus("ä»…ç¿»è¯‘æ¨¡å¼è¯·ä¸Šä¼  .srt æ–‡ä»¶", "error");
          return;
        }
        if (translationApi.value === "none" || translateTo.value === "none") {
          showStatus("è¯·é€‰æ‹©ç¿»è¯‘ API ä¸ç›®æ ‡è¯­è¨€", "error");
          return;
        }
      } else {
        if (translationApi.value !== "none" && translateTo.value === "none") {
          showStatus("å·²é€‰æ‹©ç¿»è¯‘ APIï¼Œè¯·åŒæ—¶é€‰æ‹©â€œç¿»è¯‘æˆâ€ç›®æ ‡è¯­è¨€", "error");
          return;
        }
        if (translationApi.value === "none" && translateTo.value !== "none") {
          showStatus("å·²é€‰æ‹©â€œç¿»è¯‘æˆâ€ç›®æ ‡è¯­è¨€ï¼Œè¯·åŒæ—¶é€‰æ‹©ç¿»è¯‘ API", "error");
          return;
        }
      }

      saveApiConfig();
      submitBtn.disabled = true;
      cancelBtn.disabled = false;
      stopQueue = false;
      downloadList.innerHTML = "";
      parallelTaskStates.clear();
      parallelRunEnabled = false;
      parallelTotalFiles = 0;
      parallelFileNames = files.map((f) => f.name);
      autoDownloadChain = Promise.resolve();
      parallelDetailList.innerHTML = "";
      parallelDetailPanel.style.display = "none";

      let okCount = 0;
      let failCount = 0;
      try {
        const canParallel = ["openai", "gemini"].includes(translationApi.value);
        const workerCount = (batchMode && canParallel) ? Math.min(getParallelFileCount(), files.length) : 1;
        parallelRunEnabled = workerCount > 1;
        parallelTotalFiles = files.length;
        if (parallelRunEnabled) {
          for (let i = 0; i < files.length; i++) {
            parallelTaskStates.set(i + 1, {
              status: "queued",
              progress: 0,
              fileName: files[i].name,
              message: "ç­‰å¾…è°ƒåº¦â€¦",
            });
          }
          renderParallelStatus();
          renderParallelDetails();
        }
        let nextIndex = 0;
        showStatus(
          workerCount > 1
            ? `<span class="spinner"></span>é˜Ÿåˆ—å¹¶è¡Œæ‰§è¡Œä¸­ï¼ˆå¹¶å‘ ${workerCount}ï¼‰`
            : `<span class="spinner"></span>é˜Ÿåˆ—æ‰§è¡Œä¸­ï¼ˆä¸²è¡Œï¼‰`,
          "loading"
        );
        showProgress(0, null);

        const worker = async () => {
          while (true) {
            if (stopQueue) return;
            const i = nextIndex++;
            if (i >= files.length) return;
            const file = files[i];
            if (!parallelRunEnabled) {
              fileName.textContent = `å¤„ç†ä¸­ ${i + 1}/${files.length}ï¼š${file.name}`;
            } else {
              setParallelTaskState(i + 1, {
                status: "running",
                progress: 0,
                fileName: file.name,
                message: "æäº¤ä»»åŠ¡ä¸­â€¦",
              });
            }
            try {
              const result = await runSingleFileTask(file, onlyTranslate, i + 1, files.length, batchMode);
              if (result.ok) okCount += 1;
              else failCount += 1;
            } catch (e) {
              const msg = String((e && e.message) || e);
              if (stopQueue || msg.includes("å–æ¶ˆ") || msg.includes("é˜Ÿåˆ—å·²åœæ­¢")) {
                return;
              }
              failCount += 1;
              if (parallelRunEnabled) {
                setParallelTaskState(i + 1, {
                  status: "fail",
                  progress: 100,
                  fileName: file.name,
                  message: msg,
                });
              } else {
                showStatus(`æ–‡ä»¶ ${i + 1}/${files.length} å¤±è´¥ï¼š${msg}`, "error");
              }
            }
          }
        };

        const workers = Array.from({ length: workerCount }, () => worker());
        await Promise.all(workers);

        if (stopQueue) {
          if (parallelRunEnabled) {
            for (let i = 1; i <= files.length; i++) {
              const state = parallelTaskStates.get(i) || { fileName: parallelFileNames[i - 1] || `æ–‡ä»¶ ${i}` };
              if (state.status !== "done" && state.status !== "fail" && state.status !== "canceled") {
                parallelTaskStates.set(i, {
                  ...state,
                  status: "canceled",
                  message: "å·²åœæ­¢",
                  progress: Number.isFinite(state.progress) ? state.progress : 0,
                });
              }
            }
            renderParallelStatus();
            renderParallelDetails();
          }
          const donePercent = files.length ? Math.round(((okCount + failCount) / files.length) * 100) : 0;
          showProgress(donePercent, null);
          showStatus(`é˜Ÿåˆ—å·²åœæ­¢ï¼šæˆåŠŸ ${okCount}ï¼Œå¤±è´¥ ${failCount}`, "success");
        } else if (files.length > 1) {
          showProgress(100, null);
          showStatus(`é˜Ÿåˆ—å®Œæˆï¼šæˆåŠŸ ${okCount}ï¼Œå¤±è´¥ ${failCount}`, failCount ? "error" : "success");
        }
      } catch (e) {
        progressBarWrap.style.display = "none";
        progressEta.textContent = "";
        showStatus("å¤±è´¥ï¼š" + (e.message || String(e)), "error");
      } finally {
        activeJobIds.clear();
        parallelRunEnabled = false;
        parallelTotalFiles = 0;
        cancelBtn.disabled = true;
        submitBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
